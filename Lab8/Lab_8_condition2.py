import numpy as npimport cv2import open3d as o3dimport os# ==============================================================================# 1. STEREO SETTINGS (SEMI-GLOBAL BLOCK MATCHING - SGBM)# ==============================================================================MIN_DISPARITY = 0NUM_DISPARITIES = 128  # Disparity search range (Must be divisible by 16)BLOCK_SIZE = 7  # Block size for SGBMSAD_WINDOW_SIZE = BLOCK_SIZE  # Used in P1/P2 penalty calculation# ==============================================================================# 2. IMAGE LOADING# ==============================================================================LEFT_IMAGE_PATH = "view0.png"RIGHT_IMAGE_PATH = "view2.png"print(f"Loading images: {LEFT_IMAGE_PATH} and {RIGHT_IMAGE_PATH}")left_image = cv2.imread(LEFT_IMAGE_PATH, cv2.IMREAD_COLOR)right_image = cv2.imread(RIGHT_IMAGE_PATH, cv2.IMREAD_COLOR)if left_image is None or right_image is None:    raise FileNotFoundError(        f"Files not found: {LEFT_IMAGE_PATH} or {RIGHT_IMAGE_PATH}. Ensure they are in the script's directory.")# ==============================================================================# 3. CORE FUNCTIONS# ==============================================================================def compute_disparity(img_left, img_right):    """    Computes the disparity map between two images using StereoSGBM.    """    # Convert to grayscale for disparity calculation    gray_left = cv2.cvtColor(img_left, cv2.COLOR_BGR2GRAY)    gray_right = cv2.cvtColor(img_right, cv2.COLOR_BGR2GRAY)    stereo_matcher = cv2.StereoSGBM_create(        minDisparity=MIN_DISPARITY,        numDisparities=NUM_DISPARITIES,        blockSize=BLOCK_SIZE,        # P1 and P2 control the penalty for disparity changes        P1=8 * 3 * SAD_WINDOW_SIZE ** 2,        P2=32 * 3 * SAD_WINDOW_SIZE ** 2,        disp12MaxDiff=1,        uniquenessRatio=10,        speckleWindowSize=100,        speckleRange=32,        mode=cv2.STEREO_SGBM_MODE_SGBM_3WAY    )    # Compute returns disparity * 16.0, divide to get actual value    disparity_map = stereo_matcher.compute(gray_left, gray_right).astype(np.float32) / 16.0    return disparity_mapdef generate_point_cloud(color_image, disparity_map):    """    Converts the disparity map into a 3D point cloud using the reprojection matrix Q.    Assumes an uncalibrated camera with approximate focal length.    """    height, width = color_image.shape[:2]    # Approximate focal length (f)    focal_length = 0.8 * width    # Reprojection Matrix (Q) - Simplified for uncalibrated image    # Q maps a (u, v, disp) point to (x, y, z, w) 3D coordinates.    reprojection_matrix_Q = np.float32([[1, 0, 0, -0.5 * width],                                        [0, -1, 0, 0.5 * height],                                        [0, 0, 0, -focal_length],                                        [0, 0, 1, 0]])    points_3d = cv2.reprojectImageTo3D(disparity_map, reprojection_matrix_Q)    point_colors = cv2.cvtColor(color_image, cv2.COLOR_BGR2RGB)    # Reshape arrays from (H, W, 3) to (N, 3) for Open3D    points_flat = points_3d.reshape(-1, 3)    colors_flat = point_colors.reshape(-1, 3)    disparity_flat = disparity_map.reshape(-1)    # Filtering points: removing points with invalid (minimum) or extreme depth    validity_mask = (disparity_flat > disparity_map.min()) & \                    (points_flat[:, 2] < 10000) & \                    (points_flat[:, 2] > -10000)    # Return only the valid points and colors    return points_flat[validity_mask], colors_flat[validity_mask]# ==============================================================================# 4. MAIN EXECUTION# ==============================================================================if __name__ == '__main__':    print("\n--- Starting 3D Reconstruction Process ---")    # --- A. Compute Disparity ---    disparity_result = compute_disparity(left_image, right_image)    # Visualize and save the disparity map    disparity_normalized = cv2.normalize(disparity_result, None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX)    disparity_visualization_img = np.uint8(disparity_normalized)    output_disparity_path = "disparity_map_output.png"    cv2.imwrite(output_disparity_path, disparity_visualization_img)    print(f"Disparity map saved as: {output_disparity_path}")    # [Image of Disparity Map visualization]    # --- B. Generate Point Cloud ---    print("\nGenerating 3D Point Cloud...")    cloud_points, cloud_colors = generate_point_cloud(left_image, disparity_result)    # Create Open3D Point Cloud object    point_cloud_o3d = o3d.geometry.PointCloud()    point_cloud_o3d.points = o3d.utility.Vector3dVector(cloud_points)    # Normalize colors to [0, 1] range for Open3D    point_cloud_o3d.colors = o3d.utility.Vector3dVector(cloud_colors / 255.0)    # --- C. Clean and Center ---    print("Noise filtering (Statistical Outlier Removal)...")    # remove_statistical_outlier: removes points with too few neighbors    _, indices_to_keep = point_cloud_o3d.remove_statistical_outlier(nb_neighbors=50, std_ratio=1.0)    point_cloud_o3d = point_cloud_o3d.select_by_index(indices_to_keep)    print("Centering model for optimal visualization...")    center_of_cloud = point_cloud_o3d.get_center()    point_cloud_o3d.translate(-center_of_cloud)  # Move to origin (0, 0, 0)    # --- D. Visualize ---    print("\nVisualizing 3D Model with Open3D...")    o3d.visualization.draw_geometries([point_cloud_o3d],                                      window_name="3D Reconstruction (Final Model)",                                      width=1000,                                      height=800,                                      point_show_normal=False)    print("\n--- Process Finished Successfully! ---")